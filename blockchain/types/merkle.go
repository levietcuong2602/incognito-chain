package types

import (
	"bytes"
	"fmt"
	"github.com/incognitochain/incognito-chain/privacy/coin"
	"math"
	"sort"

	"github.com/incognitochain/incognito-chain/common"
	"github.com/incognitochain/incognito-chain/metadata"
	"github.com/incognitochain/incognito-chain/privacy"
	"github.com/incognitochain/incognito-chain/transaction"
)

// BuildKeccak256MerkleTree creates a merkle tree using Keccak256 hash func.
// This merkle tree is used for storing all beacon (and bridge) data to relay them to Ethereum.
func BuildKeccak256MerkleTree(data [][]byte) [][]byte {
	if len(data) == 0 {
		emptyRoot := [32]byte{}
		return [][]byte{emptyRoot[:]}
	}
	// Calculate how many entries are required to hold the binary merkle
	// tree as a linear array and create an array of that size.
	nextPoT := NextPowerOfTwo(len(data))
	arraySize := nextPoT*2 - 1
	merkles := make([][]byte, arraySize)

	// Create the base data hashes and populate the array with them.
	for i, d := range data {
		h := common.Keccak256(d)
		merkles[i] = h[:]
	}

	// Start the array offset after the last data and adjusted to the
	// next power of two.
	offset := nextPoT
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil too.
		case merkles[i] == nil:
			merkles[offset] = nil

			// When there is no right child, the parent is generated by
			// hashing the concatenation of the left child with itself.
		case merkles[i+1] == nil:
			newHash := keccak256MerkleBranches(merkles[i], merkles[i])
			merkles[offset] = newHash

			// The normal case sets the parent node to the keccak256
			// of the concatentation of the left and right children.
		default:
			newHash := keccak256MerkleBranches(merkles[i], merkles[i+1])
			merkles[offset] = newHash
		}
		offset++
	}

	return merkles
}

func GetKeccak256MerkleRoot(data [][]byte) []byte {
	merkles := BuildKeccak256MerkleTree(data)
	return merkles[len(merkles)-1]
}

func GetKeccak256MerkleProofFromTree(merkles [][]byte, id int) ([][]byte, []bool) {
	path := [][]byte{}
	left := []bool{}
	height := uint(math.Log2(float64(len(merkles))))
	start := 0
	for i := uint(0); i < height; i++ {
		sibling := id ^ 1
		path = append(path, merkles[sibling])
		left = append(left, sibling < id)

		id = (id-start)/2 + start + (1 << (height - i)) // Go to parent node
		start += 1 << (height - i)
	}
	return path, left
}

// keccak256MerkleBranches concatenates the 2 branches of a Merkle tree and hash it to create the parent node using Keccak256 hash function
func keccak256MerkleBranches(left []byte, right []byte) []byte {
	// Concatenate the left and right nodes.
	hash := append(left, right...)
	newHash := common.Keccak256(hash)
	return newHash[:]
}

type Merkle struct {
}

// BuildMerkleTreeStore creates a merkle tree from a slice of transactions,
// stores it using a linear array, and returns a slice of the backing array.  A
// linear array was chosen as opposed to an actual tree structure since it uses
// about half as much memory.  The following describes a merkle tree and how it
// is stored in a linear array.
//
// A merkle tree is a tree in which every non-leaf node is the hash of its
// children nodes.  A diagram depicting how this works for Incognito transactions
// where h(x) is a double sha256 follows:
//
//	         root = h1234 = h(h12 + h34)
//	        /                           \
//	  h12 = h(h1 + h2)            h34 = h(h3 + h4)
//	   /            \              /            \
//	h1 = h(tx1)  h2 = h(tx2)    h3 = h(tx3)  h4 = h(tx4)
//
// The above stored as a linear array is as follows:
//
// 	[h1 h2 h3 h4 h12 h34 root]
//
// As the above shows, the merkle root is always the last element in the array.
//
// The number of inputs is not always a power of two which results in a
// balanced tree structure as above.  In that case, parent nodes with no
// children are also zero and parent nodes with only a single left node
// are calculated by concatenating the left node with itself before hashing.
// Since this function uses nodes that are pointers to the hashes, empty nodes
// will be nil.
//
// The additional bool parameter indicates if we are generating the merkle tree
// using witness transaction id's rather than regular transaction id's. This
// also presents an additional case wherein the wtxid of the salary transaction
// is the zeroHash.
func (merkle Merkle) BuildMerkleTreeStore(transactions []metadata.Transaction) []*common.Hash {
	if len(transactions) == 0 {
		return []*common.Hash{}
	}
	// Calculate how many entries are required to hold the binary merkle
	// tree as a linear array and create an array of that size.
	nextPoT := NextPowerOfTwo(len(transactions))
	arraySize := nextPoT*2 - 1
	merkles := make([]*common.Hash, arraySize)

	// Create the base transaction hashes and populate the array with them.
	for i, tx := range transactions {
		merkles[i] = tx.Hash()
	}

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	offset := nextPoT
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil too.
		case merkles[i] == nil:
			merkles[offset] = nil

			// When there is no right child, the parent is generated by
			// hashing the concatenation of the left child with itself.
		case merkles[i+1] == nil:
			newHash := merkle.hashMerkleBranches(merkles[i], merkles[i])
			merkles[offset] = newHash

			// The normal case sets the parent node to the double sha256
			// of the concatentation of the left and right children.
		default:
			newHash := merkle.hashMerkleBranches(merkles[i], merkles[i+1])
			merkles[offset] = newHash
		}
		offset++
	}

	return merkles
}

func (merkle Merkle) BuildMerkleTreeOfHashes(shardsHash []*common.Hash, length int) []*common.Hash {
	// Calculate how many entries are required to hold the binary merkle
	// tree as a linear array and create an array of that size.
	nextPoT := NextPowerOfTwo(length)
	arraySize := nextPoT*2 - 1
	merkles := make([]*common.Hash, arraySize)

	// Create the base transaction hashes and populate the array with them.
	copy(merkles, shardsHash)
	for i := len(shardsHash); i < len(merkles); i++ {
		merkles[i], _ = common.Hash{}.NewHashFromStr("")
	}

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	offset := nextPoT
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil too.
		case merkles[i] == nil:
			merkles[offset] = nil

			// When there is no right child, the parent is generated by
			// hashing the concatenation of the left child with itself.
		case merkles[i+1] == nil:
			newHash := merkle.hashMerkleBranches(merkles[i], merkles[i])
			merkles[offset] = newHash

			// The normal case sets the parent node to the double sha256
			// of the concatentation of the left and right children.
		default:
			newHash := merkle.hashMerkleBranches(merkles[i], merkles[i+1])
			merkles[offset] = newHash
		}
		offset++
	}
	return merkles
}

func (merkle Merkle) VerifyMerkleRootOfHashes(merkleTree []*common.Hash, merkleRoot *common.Hash, length int) bool {
	res := merkle.BuildMerkleTreeOfHashes(merkleTree, length)
	tempRoot := res[len(res)-1].GetBytes()
	return bytes.Equal(tempRoot, merkleRoot.GetBytes())
}

func (merkle Merkle) BuildMerkleTreeOfHashes2(shardsHashes []common.Hash, length int) []common.Hash {
	// tempShardsHashes := make([]*common.Hash, len(shardsHashes))

	tempShardsHashes := []*common.Hash{}

	for _, value := range shardsHashes {
		newHash, _ := common.Hash{}.NewHashFromStr(value.String())
		tempShardsHashes = append(tempShardsHashes, newHash)
	}
	merkleData := merkle.BuildMerkleTreeOfHashes(tempShardsHashes, length)
	tempMerkleData := make([]common.Hash, len(merkleData))
	for i, value := range merkleData {
		tempMerkleData[i] = *value
	}
	return tempMerkleData
}
func (merkle Merkle) VerifyMerkleRootOfHashes2(merkleTree []common.Hash, merkleRoot common.Hash, length int) bool {
	res := merkle.BuildMerkleTreeOfHashes2(merkleTree, length)
	tempRoot := res[len(res)-1].GetBytes()
	return bytes.Equal(tempRoot, merkleRoot.GetBytes())
}

func (merkle Merkle) GetMerklePathForCrossShard(length int, merkleTree []common.Hash, shardID byte) (merklePathShard []common.Hash, merkleShardRoot common.Hash) {
	nextPoT := NextPowerOfTwo(length)
	// merkleSize := nextPoT*2 - 1
	cursor := 0
	lastCursor := 0
	sid := int(shardID)
	i := sid
	time := 0
	for {
		if cursor >= len(merkleTree)-2 {
			break
		}
		if i%2 == 0 {
			merklePathShard = append(merklePathShard, merkleTree[cursor+i+1])
		} else {
			merklePathShard = append(merklePathShard, merkleTree[cursor+i-1])
		}
		i = i / 2

		if time == 0 {
			cursor += nextPoT
		} else {
			tmp := cursor
			cursor += (cursor - lastCursor) / 2
			lastCursor = tmp
		}
		time++
	}
	merkleShardRoot = merkleTree[len(merkleTree)-1]
	return merklePathShard, merkleShardRoot
}
func (merkle Merkle) VerifyMerkleRootFromMerklePath(leaf common.Hash, merklePath []common.Hash, merkleRoot common.Hash, receiverShardID byte) bool {

	i := int(receiverShardID)
	finalHash := &leaf
	for _, hashPath := range merklePath {
		if i%2 == 0 {
			finalHash = merkle.hashMerkleBranches(finalHash, &hashPath)
		} else {
			finalHash = merkle.hashMerkleBranches(&hashPath, finalHash)
		}
		i = i / 2
	}
	merkleRootPointer := &merkleRoot
	return merkleRootPointer.IsEqual(finalHash)
}

// nextPowerOfTwo returns the next highest power of two from a given number if
// it is not already a power of two.  This is a helper function used during the
// calculation of a merkle tree.
func NextPowerOfTwo(n int) int {
	// Return the number if it's already a power of 2.
	if n&(n-1) == 0 {
		return n
	}

	// Figure out and return the next power of two.
	exponent := uint(math.Log2(float64(n))) + 1
	return 1 << exponent // 2^exponent
}

/*
hashMerkleBranches takes two hashes, treated as the left and right tree
nodes, and returns the hash of their concatenation.  This is a helper
function used to aid in the generation of a merkle tree.
*/
func (merkle Merkle) hashMerkleBranches(left *common.Hash, right *common.Hash) *common.Hash {
	// Concatenate the left and right nodes.
	var hash [common.HashSize * 2]byte
	copy(hash[:common.HashSize], left[:])
	copy(hash[common.HashSize:], right[:])

	newHash := common.HashH(hash[:])
	return &newHash
}

func CalcMerkleRoot(txns []metadata.Transaction) common.Hash {
	if len(txns) == 0 {
		return common.Hash{}
	}

	utilTxns := make([]metadata.Transaction, 0, len(txns))
	utilTxns = append(utilTxns, txns...)
	merkles := Merkle{}.BuildMerkleTreeStore(utilTxns)
	return *merkles[len(merkles)-1]
}

//====================New Merkle Tree================
// CreateShardTxRoot create root hash for cross shard transaction
// this root hash will be used be received shard
func CreateShardTxRoot(txList []metadata.Transaction) ([]common.Hash, []common.Hash) {
	//calculate output coin hash for each shard
	crossShardDataHash := getCrossShardDataHash(txList)
	// calculate merkel path for a shardID
	// step 1: calculate merkle data : [1, 2, 3, 4, 12, 34, 1234]
	/*
			   	1234=hash(12,34)
			   /			  \
		  12=hash(1,2)	 34=hash(3,4)
			 / \	 		 / \
			1	2			3	4
	*/
	merkleTree := Merkle{}
	merkleData := merkleTree.BuildMerkleTreeOfHashes2(crossShardDataHash, common.MaxShardNumber)
	return crossShardDataHash, merkleData
}

func GetMerklePathCrossShard(txList []metadata.Transaction, shardID byte) (merklePathShard []common.Hash, merkleShardRoot common.Hash) {
	_, merkleTree := CreateShardTxRoot(txList)
	merklePathShard, merkleShardRoot = Merkle{}.GetMerklePathForCrossShard(common.MaxShardNumber, merkleTree, shardID)
	return merklePathShard, merkleShardRoot
}

//  getCrossShardDataHash
//	Helper function: group OutputCoin into shard and get the hash of each group
//	Return value
//	 - Array of hash created from 256 group cross shard data hash
//	 - Length array is 256
//	 - Value is sorted as shardID from low to high
//	 - ShardID which have no outputcoin received hash of emptystring value
//
//	Hash Procedure:
//	- For each shard:
//	   CROSS OUTPUT COIN
//		+ Get outputcoin and append to a list of that shard
//		+ Calculate value for Hash:
//		  * if receiver shard has no outcoin then received hash value of empty string
//		  * if receiver shard has >= 1 outcoin then concatenate all outcoin bytes value then hash
//	      * At last, we compress all cross out put coin into a CrossOutputCoinFinalHash
//	   TXTOKENDATA
//		+ Do the same as above
//	   => Then Final Hash of each shard is Hash of value in this order:
//		1. CrossOutputCoinFinalHash
//		2. TxTokenDataVoutFinalHash
//	TxTokenOut DataStructure
//	- Use Only One TxNormalTokenData for one TokenID
//	- Vouts of one tokenID from many transaction will be compress into One Vouts List
//	- Using Key-Value structure for accessing one token ID data:
//	  key: token ID
//	  value: TokenData of that token
func getCrossShardDataHash(txList []metadata.Transaction) []common.Hash {
	// group transaction by shardID
	txTokenPrivacyDataMap := make([]map[common.Hash]*ContentCrossShardTokenPrivacyData, common.MaxShardNumber)
	outCoinEachShard := make([][]privacy.Coin, common.MaxShardNumber)
	for _, tx := range txList {
		switch tx.GetType() {
		//==================For PRV Transfer Only
		//TxReturnStakingType cannot be crossshard tx
		case common.TxNormalType, common.TxRewardType, common.TxConversionType:
			{
				// Proof Process
				if tx.GetProof() != nil {
					for _, outCoin := range tx.GetProof().GetOutputCoins() {
						shardID, err := outCoin.GetShardID()
						if err == nil {
							outCoinEachShard[shardID] = append(outCoinEachShard[shardID], outCoin)
						}
					}
				}
			}
		case common.TxCustomTokenPrivacyType, common.TxTokenConversionType:
			{
				customTokenPrivacyTx, ok := tx.(transaction.TransactionToken)
				if !ok {
					continue
				}
				//==================Proof Process
				txProof := customTokenPrivacyTx.GetTxBase().GetProof()
				if txProof != nil {
					for _, outCoin := range txProof.GetOutputCoins() {
						shardID, err := outCoin.GetShardID()
						if err == nil {
							outCoinEachShard[shardID] = append(outCoinEachShard[shardID], outCoin)
						}
					}
				}
				//==================Tx Token Privacy Data Process
				txTokenData := customTokenPrivacyTx.GetTxTokenData()
				txTokenProof := txTokenData.TxNormal.GetProof()
				if txTokenProof != nil {
					for _, outCoin := range txTokenProof.GetOutputCoins() {
						shardID, err := outCoin.GetShardID()
						if err == nil {
							if txTokenPrivacyDataMap[shardID] == nil {
								txTokenPrivacyDataMap[shardID] = make(map[common.Hash]*ContentCrossShardTokenPrivacyData)
							}
							if _, ok := txTokenPrivacyDataMap[shardID][txTokenData.PropertyID]; !ok {
								contentCrossTokenPrivacyData := CloneTxTokenPrivacyDataForCrossShard(txTokenData)
								txTokenPrivacyDataMap[shardID][txTokenData.PropertyID] = &contentCrossTokenPrivacyData
							}
							txTokenPrivacyDataMap[shardID][txTokenData.PropertyID].OutputCoin = append(txTokenPrivacyDataMap[shardID][txTokenData.PropertyID].OutputCoin, outCoin)
						}
					}
				}
			}
		}
	}
	//calcualte hash for each shard
	outputCoinHash := make([]common.Hash, common.MaxShardNumber)
	txTokenOutHash := make([]common.Hash, common.MaxShardNumber)
	txTokenPrivacyOutHash := make([]common.Hash, common.MaxShardNumber)
	combinedHash := make([]common.Hash, common.MaxShardNumber)
	for i := 0; i < common.MaxShardNumber; i++ {
		outputCoinHash[i] = calHashOutCoinCrossShard(outCoinEachShard[i])
		txTokenOutHash[i] = calHashTxTokenDataHashFromMap()
		txTokenPrivacyOutHash[i] = calHashTxTokenPrivacyDataHashFromMap(txTokenPrivacyDataMap[i])

		tmpByte := append(append(outputCoinHash[i].GetBytes(), txTokenOutHash[i].GetBytes()...), txTokenPrivacyOutHash[i].GetBytes()...)
		combinedHash[i] = common.HashH(tmpByte)
	}
	return combinedHash
}

func calHashOutCoinCrossShard(outCoins []coin.Coin) common.Hash {
	tmpByte := []byte{}
	var outputCoinHash common.Hash
	if len(outCoins) != 0 {
		for _, outCoin := range outCoins {
			if outCoin == nil {
				for i := 0; i < len(outCoins); i++ {
					fmt.Println("Outcoin ", i, outCoins[i])
				}
				fmt.Println("Number of outcoins: ", len(outCoins))
			}
			tmpByte = append(tmpByte, outCoin.Bytes()...)
		}
		outputCoinHash = common.HashH(tmpByte)
	} else {
		outputCoinHash = common.HashH([]byte(""))
	}
	return outputCoinHash
}

func calHashTxTokenDataHashFromMap() common.Hash {
	return common.HashH([]byte(""))
}

func calHashTxTokenPrivacyDataHashFromMap(txTokenPrivacyDataMap map[common.Hash]*ContentCrossShardTokenPrivacyData) common.Hash {
	if len(txTokenPrivacyDataMap) == 0 {
		return common.HashH([]byte(""))
	}
	var txTokenPrivacyDataList []ContentCrossShardTokenPrivacyData
	for _, value := range txTokenPrivacyDataMap {
		txTokenPrivacyDataList = append(txTokenPrivacyDataList, *value)
	}
	sort.SliceStable(txTokenPrivacyDataList[:], func(i, j int) bool {
		return txTokenPrivacyDataList[i].PropertyID.String() < txTokenPrivacyDataList[j].PropertyID.String()
	})
	return calHashTxTokenPrivacyDataHashList(txTokenPrivacyDataList)
}

func calHashTxTokenPrivacyDataHashList(txTokenPrivacyDataList []ContentCrossShardTokenPrivacyData) common.Hash {
	tmpByte := []byte{}
	if len(txTokenPrivacyDataList) != 0 {
		for _, txTokenPrivacyData := range txTokenPrivacyDataList {
			tempHash := txTokenPrivacyData.Hash()
			tmpByte = append(tmpByte, tempHash.GetBytes()...)

		}
	} else {
		return common.HashH([]byte(""))
	}
	return common.HashH(tmpByte)
}

func calHashTxTokenDataHashList() common.Hash {
	return common.HashH([]byte(""))
}
